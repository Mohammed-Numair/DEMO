<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Face Attendance System (Client-Side)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

  <style>
    :root {
        --primary-color: #007bff;
        --primary-hover-color: #0056b3;
        --background-color: #f0f2f5;
        --card-background-color: #ffffff;
        --text-color: #333;
        --border-color: #ddd;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --success-color: #28a745;
        --error-color: #dc3545;
        --warning-color: #ffc107;
    }
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    h1 {
        text-align: center;
        color: var(--primary-color);
        font-size: 2.5rem;
        margin-bottom: 25px;
    }
    nav.tabs {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 30px;
        flex-wrap: wrap;
    }
    nav.tabs button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 20px;
        padding: 10px 25px;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }
    nav.tabs button:hover {
        background-color: var(--primary-hover-color);
    }
    nav.tabs button.active {
        background-color: var(--primary-hover-color);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    main {
        width: 100%;
        max-width: 700px;
        margin: 0 auto;
        background-color: var(--card-background-color);
        padding: 40px;
        border-radius: 12px;
        box-shadow: 0 4px 12px var(--shadow-color);
        box-sizing: border-box;
    }
    .tab-content.hidden {
        display: none;
    }
    .tab-content h2 {
        text-align: center;
        font-size: 1.8rem;
        margin-top: 0;
        margin-bottom: 30px;
    }
    .form-group {
        margin-bottom: 20px;
    }
    label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
    }
    input[type="text"],
    input[type="number"],
    select {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 1rem;
        box-sizing: border-box;
        transition: border-color 0.3s, box-shadow 0.3s;
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2);
    }
    .btn-primary, .btn-secondary {
        color: white;
        border: none;
        border-radius: 8px;
        padding: 12px 25px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        display: block;
        width: 100%;
        margin-top: 10px;
        text-align: center;
        transition: background-color 0.3s ease;
    }
    .btn-primary { background-color: var(--primary-color); }
    .btn-primary:hover { background-color: var(--primary-hover-color); }
    .btn-secondary { background-color: #6c757d; margin-top: 20px; }
    .btn-secondary:hover { background-color: #5a6268; }
    .video-container {
        position: relative;
        width: 100%;
        max-width: 400px;
        margin: 20px auto;
    }
    video {
        display: block;
        width: 100%;
        border-radius: 8px;
        background-color: #000;
        border: 3px solid var(--border-color);
        transform: scaleX(-1);
    }
    .status-message {
        text-align: center;
        margin-top: 20px;
        font-weight: 500;
        min-height: 24px;
        padding: 10px;
        border-radius: 8px;
        word-wrap: break-word;
    }
    .status-message.success { color: var(--success-color); background-color: rgba(40, 167, 69, 0.1); }
    .status-message.error { color: var(--error-color); background-color: rgba(220, 53, 69, 0.1); }
    .status-message.warning { color: #856404; background-color: rgba(255, 193, 7, 0.1); }
    .status-message.info { color: #004085; background-color: rgba(0, 123, 255, 0.1); }
    .divider { border: 0; height: 1px; background: #eee; margin: 30px 0; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
    th { background-color: #f8f9fa; }
    #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.5rem;
        font-weight: bold;
        z-index: 1000;
    }
  </style>
</head>

<body>
  <div id="loading-overlay">Loading AI Models...</div>

  <h1>🎥 Face Attendance System</h1>

  <nav class="tabs">
    <button data-tab="enroll" class="active">Enroll</button>
    <button data-tab="scan">Scan</button>
    <button data-tab="manual">Manual Attendance</button>
    <button data-tab="reports">Reports</button>
  </nav>

  <main>
    <div id="enroll" class="tab-content">
      <h2>Enroll Student</h2>
      <div class="form-group">
        <label for="studentRoll">Roll Number:</label>
        <input id="studentRoll" type="text" placeholder="Enter unique Roll Number" required>
      </div>
      <div class="form-group">
        <label for="studentName">Name:</label>
        <input id="studentName" type="text" placeholder="Enter Student's Full Name" required>
      </div>
        <div class="form-group">
        <label for="studentClass">Class:</label>
        <input id="studentClass" type="text" placeholder="e.g., 10-A, B.Tech CSE" required>
      </div>
      <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
      </div>
      <button id="enrollBtn" class="btn-primary">📸 Capture & Enroll</button>
      <p id="enrollStatus" class="status-message"></p>
    </div>

    <div id="scan" class="tab-content hidden">
      <h2>Scan for Attendance</h2>
      <div class="video-container">
          <video id="scanVideo" autoplay muted playsinline></video>
      </div>
      <button id="scanBtn" class="btn-primary">📸 Scan & Mark Attendance</button>
      <p id="scanStatus" class="status-message"></p>
    </div>
    
    <div id="manual" class="tab-content hidden">
        <h2>Manual Attendance</h2>
        <div class="form-group">
            <label for="manualRoll">Student Roll Number:</label>
            <input type="text" id="manualRoll" placeholder="Enter enrolled student's roll number">
        </div>
        <button id="manualMarkBtn" class="btn-primary">Mark Attendance</button>
        <p id="manualStatus" class="status-message"></p>
    </div>

    <div id="reports" class="tab-content hidden">
      <h2>Monthly Reports</h2>
      <div class="form-group">
        <label for="reportMonth">Select Month:</label>
        <select id="reportMonth"></select>
      </div>
      <div class="form-group">
        <label for="workingDays">No. of Working Days in Month:</label>
        <input type="number" id="workingDays" value="22" placeholder="e.g., 22">
      </div>
      <button id="generateReportBtn" class="btn-primary">Generate Report</button>
      
      <hr class="divider">

      <h3>Individual Student Report</h3>
      <button id="exportIndividualCsvBtn" class="btn-secondary">Export as CSV</button>
      <div style="overflow-x:auto;">
        <table id="individualReportTable">
          <thead>
            <tr>
              <th>Roll No.</th>
              <th>Name</th>
              <th>Class</th>
              <th>Attended</th>
              <th>Total Days</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody>
          </tbody>
        </table>
      </div>

      <h3>Overall Class Report</h3>
      <div style="overflow-x:auto;">
        <table id="classReportTable">
        <thead>
          <tr>
            <th>Total Students</th>
            <th>Total Attendance</th>
            <th>Overall Percentage</th>
          </tr>
        </thead>
        <tbody>
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Global State & Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        let currentStream;
        let faceMatcher; // This will hold our face recognition model

        // --- IndexedDB Setup ---
        const DB_NAME = 'FaceAttendanceDB_ClientSide';
        const DB_VERSION = 1;
        const STORE_STUDENTS = 'students'; // Will store roll, name, class, and face descriptor
        const STORE_ATTENDANCE = 'attendance';
        let dbPromise;

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_STUDENTS)) {
                        db.createObjectStore(STORE_STUDENTS, { keyPath: 'roll' });
                    }
                    if (!db.objectStoreNames.contains(STORE_ATTENDANCE)) {
                        const store = db.createObjectStore(STORE_ATTENDANCE, { keyPath: 'id', autoIncrement: true });
                        store.createIndex('roll_date_idx', ['roll', 'date'], { unique: false });
                    }
                };
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function dbGet(storeName, key) {
            return new Promise(async (resolve, reject) => {
                const db = await dbPromise;
                const tx = db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const request = key ? store.get(key) : store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function dbPut(storeName, data) {
            return new Promise(async (resolve, reject) => {
                const db = await dbPromise;
                const tx = db.transaction(storeName, 'readwrite');
                tx.objectStore(storeName).put(data);
                tx.oncomplete = () => resolve();
                tx.onerror = (event) => reject(event.target.error);
            });
        }
        
        const loadStudents = () => dbGet(STORE_STUDENTS);
        const saveStudent = (student) => dbPut(STORE_STUDENTS, student);
        const loadAttendance = () => dbGet(STORE_ATTENDANCE);
        const saveAttendanceRecord = (record) => dbPut(STORE_ATTENDANCE, record);
        const saveWorkingDays = (val) => localStorage.setItem('workingDays', val);
        const loadWorkingDays = () => parseInt(localStorage.getItem('workingDays') || '22');

        // --- App Initialization ---
        async function initialize() {
            dbPromise = openDB();
            await dbPromise;
            console.log("Database connection successful.");

            await loadFaceApiModels();
            
            setupTabNavigation();
            setupEnrollment();
            setupRecognition();
            setupManualAttendance();
            setupReports();
            
            await loadKnownFaces(); // Load faces and create the FaceMatcher
            loadingOverlay.style.display = 'none';
            document.querySelector('nav button').click();
        }

        async function loadFaceApiModels() {
            const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
            await Promise.all([
                faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
            ]);
            console.log("Face-API models loaded.");
        }

        async function loadKnownFaces() {
            const students = await loadStudents();
            if (students.length === 0) {
                console.log("No known faces in the database.");
                faceMatcher = null;
                return;
            }
            const labeledFaceDescriptors = students.map(s => {
                // The descriptor is stored as a plain array, convert it to Float32Array
                const descriptor = new Float32Array(Object.values(s.descriptor));
                return new faceapi.LabeledFaceDescriptors(s.roll, [descriptor]);
            });

            faceMatcher = new faceapi.FaceMatcher(labeledFaceDescriptors, 0.55);
            console.log("FaceMatcher created with known faces.");
        }

        // --- Camera Management ---
        async function startCamera(videoId) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            try {
                const videoEl = document.getElementById(videoId);
                currentStream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoEl.srcObject = currentStream;
                await videoEl.play();
            } catch (err) {
                console.error("Camera error:", err);
                alert("Could not start camera. Please ensure you have granted camera permission.");
            }
        }

        function stopCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
        }

        // --- UI & Event Listeners ---
        function setupTabNavigation() {
            document.querySelectorAll('nav button').forEach(btn => {
                btn.addEventListener('click', async () => {
                    document.querySelectorAll('.tab-content').forEach(t => t.classList.add('hidden'));
                    document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
                    
                    const tabId = btn.dataset.tab;
                    document.getElementById(tabId).classList.remove('hidden');
                    btn.classList.add('active');

                    stopCamera();
                    
                    if (tabId === 'enroll') await startCamera('video');
                    if (tabId === 'scan') await startCamera('scanVideo');

                    if (tabId === 'reports') {
                        document.getElementById('workingDays').value = loadWorkingDays();
                        await populateMonthSelector();
                        await handleGenerateReport();
                    }
                });
            });
        }
        
        function setStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = 'status-message';
            if (type) el.classList.add(type);
        }

        function speak(text) {
            try {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utter = new SpeechSynthesisUtterance(text);
                    window.speechSynthesis.speak(utter);
                }
            } catch (e) { console.error('Speech synthesis error', e); }
        }

        // --- Enrollment Logic ---
        function setupEnrollment() {
            document.getElementById('enrollBtn').addEventListener('click', handleEnroll);
        }

        async function handleEnroll() {
            const roll = document.getElementById('studentRoll').value.trim();
            const name = document.getElementById('studentName').value.trim();
            const sClass = document.getElementById('studentClass').value.trim();
            
            if (!roll || !name || !sClass) {
                alert("Please fill in all student details.");
                return;
            }

            setStatus('enrollStatus', "Detecting face...", 'info');
            const videoEl = document.getElementById('video');
            
            const detection = await faceapi.detectSingleFace(videoEl, new faceapi.TinyFaceDetectorOptions())
                                           .withFaceLandmarks()
                                           .withFaceDescriptor();

            if (!detection) {
                setStatus('enrollStatus', "❌ No face found. Please get closer or ensure good lighting.", 'error');
                return;
            }
            
            const studentData = {
                roll: roll,
                name: name,
                class: sClass,
                descriptor: detection.descriptor
            };

            await saveStudent(studentData);
            await loadKnownFaces(); // Reload the face matcher with the new face

            setStatus('enrollStatus', ✅ Student ${name} (${roll}) enrolled successfully., 'success');
            speak("Student enrolled successfully.");
            
            // Clear fields
            document.getElementById('studentRoll').value = '';
            document.getElementById('studentName').value = '';
            document.getElementById('studentClass').value = '';
        }

        // --- Recognition Logic ---
        function setupRecognition() {
            document.getElementById('scanBtn').addEventListener('click', handleScan);
        }
        
        async function handleScan() {
            if (!faceMatcher) {
                setStatus('scanStatus', "⚠ No students enrolled yet. Please enroll students first.", 'warning');
                return;
            }

            setStatus('scanStatus', "Scanning for face...", 'info');
            const videoEl = document.getElementById('scanVideo');

            const detection = await faceapi.detectSingleFace(videoEl, new faceapi.TinyFaceDetectorOptions())
                                           .withFaceLandmarks()
                                           .withFaceDescriptor();

            if (!detection) {
                setStatus('scanStatus', "❌ No face detected. Please try again.", 'error');
                return;
            }

            const bestMatch = faceMatcher.findBestMatch(detection.descriptor);
            
            if (bestMatch.label !== 'unknown') {
                await markAttendance(bestMatch.label, 'scanStatus');
            } else {
                setStatus('scanStatus', "❌ Face not recognized. Not a known student.", 'error');
                speak("Recognition failed.");
            }
        }

        // --- Manual Attendance ---
        function setupManualAttendance() {
            document.getElementById('manualMarkBtn').addEventListener('click', handleManualMark);
        }
        
        async function handleManualMark() {
            const roll = document.getElementById('manualRoll').value.trim();
            if (!roll) {
                alert("Please enter a roll number.");
                return;
            }
            await markAttendance(roll, 'manualStatus');
            document.getElementById('manualRoll').value = '';
        }

        async function markAttendance(roll, statusElId) {
            const today = new Date().toISOString().split('T')[0];
            try {
                const student = await dbGet(STORE_STUDENTS, roll);
                if (!student) {
                    setStatus(statusElId, ❌ Roll "${roll}" not found. Please enroll this student., 'error');
                    speak("Student not enrolled.");
                    return;
                }

                const allAttendance = await loadAttendance();
                const alreadyMarked = allAttendance.find(r => r.roll === roll && r.date === today);

                if (alreadyMarked) {
                    setStatus(statusElId, ⚠ Attendance already marked today for ${student.name}., 'warning');
                    speak(Attendance already marked for ${student.name}.);
                } else {
                    await saveAttendanceRecord({
                        roll: student.roll,
                        name: student.name,
                        class: student.class,
                        time: new Date().toLocaleTimeString(),
                        date: today
                    });
                    setStatus(statusElId, ✅ Attendance marked for ${student.name}., 'success');
                    speak(Attendance marked for ${student.name}.);
                }
            } catch (error) {
                setStatus(statusElId, "❌ A database error occurred.", 'error');
            }
        }
        
        // --- Reports Section ---
        function setupReports() {
            document.getElementById('generateReportBtn').addEventListener('click', handleGenerateReport);
            document.getElementById('exportIndividualCsvBtn').addEventListener('click', handleExportIndividualCSV);
        }

        async function populateMonthSelector() {
            const monthSelect = document.getElementById('reportMonth');
            const recs = await loadAttendance();
            const monthSet = new Set(recs.map(r => r.date.substring(0, 7)));
            const sortedMonths = Array.from(monthSet).sort().reverse();
            
            monthSelect.innerHTML = '<option value="all">All Months</option>' + sortedMonths.map(month => {
                const [year, monthNum] = month.split('-');
                const monthName = new Date(year, monthNum - 1, 1).toLocaleString('default', { month: 'long' });
                return <option value="${month}">${monthName} ${year}</option>;
            }).join('');
        }

        async function calculateReportData(selectedMonth) {
            let attendance = await loadAttendance();
            if (selectedMonth !== 'all') {
                attendance = attendance.filter(r => r.date.startsWith(selectedMonth));
            }
            
            const students = await loadStudents();
            const workingDays = parseInt(document.getElementById('workingDays').value) || 22;
            saveWorkingDays(workingDays);

            const studentAttendanceDays = new Map();
            students.forEach(s => studentAttendanceDays.set(s.roll, new Set()));
            
            attendance.forEach(r => {
                if (studentAttendanceDays.has(r.roll)) {
                    studentAttendanceDays.get(r.roll).add(r.date);
                }
            });
            
            const studentRows = students.map(s => {
                const attended = studentAttendanceDays.get(s.roll)?.size || 0;
                const percentage = workingDays > 0 ? ((attended / workingDays) * 100).toFixed(1) : '0.0';
                return { ...s, attended, totalDays: workingDays, percentage };
            }).sort((a, b) => a.roll.localeCompare(b.roll, undefined, { numeric: true }));

            const totalStudents = students.length;
            const totalAttendance = studentRows.reduce((sum, s) => sum + s.attended, 0);
            const maxPossible = totalStudents * workingDays;
            const classPercentage = maxPossible > 0 ? ((totalAttendance / maxPossible) * 100).toFixed(1) : '0.0';
            const classRows = [{ totalStudents, totalAttendance, classPercentage }];

            return { studentRows, classRows };
        }

        async function handleGenerateReport() {
            const selectedMonth = document.getElementById('reportMonth').value;
            if (!selectedMonth && document.getElementById('reportMonth').options.length > 0) return; 
            
            const { studentRows, classRows } = await calculateReportData(selectedMonth || 'all');

            const sTbody = document.querySelector('#individualReportTable tbody');
            sTbody.innerHTML = studentRows.length > 0
                ? studentRows.map(r => <tr><td>${r.roll}</td><td>${r.name}</td><td>${r.class}</td><td>${r.attended}</td><td>${r.totalDays}</td><td>${r.percentage}%</td></tr>).join('')
                : '<tr><td colspan="6">No student data for selected period. Enroll students first.</td></tr>';

            const cTbody = document.querySelector('#classReportTable tbody');
            cTbody.innerHTML = classRows.map(c => <tr><td>${c.totalStudents}</td><td>${c.totalAttendance}</td><td>${c.classPercentage}%</td></tr>).join('');
        }
        
        function downloadFile(data, filename, type) {
            const blob = new Blob([data], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function handleExportIndividualCSV() {
            const selectedMonth = document.getElementById('reportMonth').value || 'all';
            const { studentRows } = await calculateReportData(selectedMonth);
            let csv = "Roll No.,Name,Class,Attended,Total Days,Percentage\n";
            studentRows.forEach(r => {
                csv += "${r.roll}","${r.name}","${r.class}",${r.attended},${r.totalDays},"${r.percentage}%"\n;
            });
            downloadFile(csv, student_report_${selectedMonth}.csv, "text/csv;charset=utf-8;");
        }
        
        // --- Start the App ---
        initialize();
    });
  </script>
</body>
</html>
